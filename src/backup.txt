use std::time::Instant;
use glam::Vec2;
use tokio::net::UdpSocket;
use anyhow::Result;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::mpsc; // Каналы!
use tokio::time::{self, Duration};
use std::net::SocketAddr;

// Внутренние команды сервера (от сети к логике)
enum GameCommand {
    Connect { addr: SocketAddr, name: String },
    TickRequest { addr: SocketAddr, x_direction: i8, y_direction: i8, direction: u8, is_attacking: bool, is_dodging: bool, current_weapon: u8, count: u8, ids: Option<Vec<u8>> },
}

struct Player {
    id: u8,
    name: String,
    health: u32,
    pos: (f32, f32), // (x, y)
    speed: u16,
    direction: u8,
    weapon: u8,
    gun: u8,
    current_weapon: u8,
    is_attacking: u8,
    is_dodging: u8,
    can_move: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    let socket = Arc::new(UdpSocket::bind("0.0.0.0:9001").await?);
    println!("UDP server listening on 9001");

    // making channel to comunicate between network cycle and game cycle
    let (tx, rx) = mpsc::channel::<GameCommand>(100);

    // starting another process for game cycle
    let socket_clone = socket.clone();
    tokio::spawn(async move {
        game_tick_loop(rx, socket_clone).await;
    });

    // --- network cycle only data recieve and parse ---
    let mut buf = [0u8; 1024];
    loop {
        let (len, addr) = socket.recv_from(&mut buf).await?;
        let data = &buf[..len];
        let req = data[0];

        match req {
            0 => { // Join request
                let name = String::from_utf8_lossy(&data[1..len]).to_string();
                    let _ = tx.try_send(GameCommand::Connect { 
                        addr,
                        name: name.to_string() 
                    });
                }
            2 => { // Tick request
                let direction = data[1];
                let x_direction = data[2] as i8;
                let y_direction = data[3] as i8;
                let is_dodging: bool = (0 != data[4]);
                let current_weapon = data[5];
                let is_attacking: bool = (0 != data[6]);
                let mut count: u8 = 0;
                if is_attacking{
                    count = data[7];
                }
                match is_attacking {
                    true => {
                        let mut ids: Vec<u8> = Vec::with_capacity(count.try_into().unwrap());
                        for i in 8..(count+8){
                            ids.push(data[i as usize]);
                        }
                        let _ = tx.try_send(GameCommand::TickRequest { 
                            addr, 
                            x_direction,
                            y_direction,
                            direction,
                            is_attacking,
                            is_dodging,
                            current_weapon,
                            count,
                            ids: Some(ids), 
                        });

                    },
                    false => {
                        let _ = tx.try_send(GameCommand::TickRequest { 
                            addr, 
                            x_direction,
                            y_direction,
                            direction,
                            is_attacking,
                            is_dodging,
                            current_weapon,
                            count,
                            ids: None, 
                        });
                    },
                }
               
            },
            _ => {}  
        }
}
}

// --- Tick cycle (game cycle) ---

async fn game_tick_loop(mut rx: mpsc::Receiver<GameCommand>, socket: Arc<UdpSocket>) {
    let mut players: HashMap<SocketAddr, Player> = HashMap::new();
    let mut next_id = 1;
    let mut tick_counter: u8 = 0;
    
    // tickrate 32 per sec (~31.25 ms)
    let tick_duration = Duration::from_millis(31); 
    let mut interval = time::interval(tick_duration);
    interval.set_missed_tick_behavior(time::MissedTickBehavior::Skip);

    loop {

        interval.tick().await;
        while let Ok(cmd) = rx.try_recv() {
            match cmd {
                GameCommand::Connect { addr, name } => {
                    if !players.contains_key(&addr) {
                        let player = Player {
                            id: next_id,
                            health: 100,
                            name: name.clone(),
                            pos: (50.0, 50.0),
                            speed: 100,
                            direction: 0,
                            gun: 0,
                            weapon: 0,
                            current_weapon: 1,
                            is_attacking: 0,                            
                            is_dodging: 0,
                            can_move: true,
                        };                        
                        // response to connect
                        let mut resp = Vec::new();

                        resp.push(0u8);
                        resp.push(tick_counter);
                        resp.extend_from_slice(&next_id.to_le_bytes());
                        resp.extend_from_slice(&player.health.to_le_bytes());
                        resp.extend_from_slice(&player.pos.0.to_le_bytes());
                        resp.extend_from_slice(&player.pos.1.to_le_bytes());

                        socket.send_to(&resp, addr).await.unwrap();
                        resp.remove(1);

                        players.insert(addr, player);
                        println!("Player {} (ID {}) connected", name, next_id);
                        next_id += 1;

                        resp[0] = 1;
                        resp.push(players.get(&addr).unwrap().name.len() as u8);
                        resp.extend_from_slice(&players.get(&addr).unwrap().name.as_bytes());
                
                        let keys: Vec<SocketAddr> = players.keys().filter(|&&p| p != addr).cloned().collect();
                        
                        for i in keys{
                            socket.send_to(&resp, &i).await.unwrap();
                            let mut resp1: Vec<u8> = vec![1u8];

                            let p = players.get(&i).unwrap();

                            resp1.push(p.id);
                            resp1.extend_from_slice(&p.health.to_le_bytes());
                            resp1.extend_from_slice(&p.pos.0.to_le_bytes());
                            resp1.extend_from_slice(&p.pos.1.to_le_bytes());
                            let name  = &p.name;
                            resp1.push(name.len() as u8);
                            resp1.extend_from_slice(name.as_bytes());


                            socket.send_to(&resp1, addr).await.unwrap();
                        }
                    }
                },
                GameCommand::TickRequest { addr, x_direction, y_direction, direction, is_attacking, is_dodging, current_weapon, count, ids} => {
                    let move_direction = Vec2::new(x_direction as f32, y_direction as f32).normalize_or_zero();
                    
                    if let Some(player) = players.get_mut(&addr) {
                        player.pos.0 += move_direction.x * player.speed as f32 * 0.03125;
                        player.pos.1 += move_direction.y * player.speed as f32 * 0.03125;
                        player.direction = direction;
                        player.is_attacking = is_attacking as u8;
                        player.is_dodging = is_dodging as u8;
                        player.current_weapon = current_weapon;
                    }
                },
            }
        }

        tick_counter += 1;
        send_game_state(&players, socket.clone(), tick_counter);
    }
}

fn send_game_state(players: &HashMap<SocketAddr, Player>, socket: Arc<UdpSocket>, tick_counter: u8){
    if players.is_empty() { return };

    let mut data: Vec<u8> = Vec::with_capacity(3 + players.len() * 20);

    data.push(2u8);
    data.push(tick_counter);
    data.push(players.len() as u8);

    for player in players.values(){
        data.push(player.id);
        data.extend_from_slice(&player.health.to_le_bytes());
        data.push(player.direction);
        data.extend_from_slice(&player.pos.0.to_le_bytes());
        data.extend_from_slice(&player.pos.1.to_le_bytes());
        data.push(player.is_attacking);
        data.push(player.is_dodging);
        data.push(player.current_weapon);
    }

    let data = Arc::new(data);
    let addrs: Vec<SocketAddr> = players.keys().cloned().collect();

    tokio::spawn(async move {
        for addr in addrs{
            let _ = socket.send_to(&data, addr).await;
        }
    });
}

fn move_and_slide(mut pos: Vec2, mut velocity: Vec2, walls: &[Wall], radius: f32) -> Vec2 {
    let mut time_left = 1.0; // Доля времени тика
    
    // Делаем до 4-х попыток скольжения (на случай углов)
    for _ in 0..4 {
        if velocity.length_squared() < 0.001 { break; }
        
        let target = pos + velocity * time_left;
        let mut collision: Option<(Vec2, Vec2)> = None; // (точка коллизии, нормаль)

        // Ищем ближайшее столкновение
        for wall in walls {
            let cp = wall.closest_point(target);
            let dist_vec = target - cp;
            let dist = dist_vec.length();

            if dist < radius {
                let normal = dist_vec.normalize_or_zero();
                collision = Some((cp, normal));
                break; 
            }
        }

        if let Some((_cp, normal)) = collision {
            // 1. Выталкиваем из стены (как в Godot)
            let overlap = radius - (target - _cp).length();
            pos = target + normal * overlap;

            // 2. Считаем вектор скольжения (проекция скорости на стену)
            // Формула: v = v - dot(v, n) * n
            velocity = velocity - normal * velocity.dot(normal);
            
            // Уменьшаем оставшееся время, чтобы не двигаться бесконечно
            time_left *= 0.5; 
        } else {
            // Если столкновений нет — просто перемещаемся
            pos = target;
            break;
        }
    }
    pos
}